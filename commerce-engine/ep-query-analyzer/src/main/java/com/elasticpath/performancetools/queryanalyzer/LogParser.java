/*
 * Copyright Â© 2018 Elastic Path Software Inc. All rights reserved.
 */
package com.elasticpath.performancetools.queryanalyzer;

import java.io.BufferedReader;
import java.io.File;
import java.nio.file.Files;
import java.util.Arrays;
import java.util.Comparator;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.elasticpath.performancetools.queryanalyzer.beans.QueryStatistics;
import com.elasticpath.performancetools.queryanalyzer.exceptions.QueryAnalyzerException;
import com.elasticpath.performancetools.queryanalyzer.parser.ParserChain;

/**
 * Cortex log parser used for producing db query statistics based on TRACE log lines generated by OpenJPA,
 * AnnotatedMethodDispatcher and ResourceLinker classes.
 * <p>
 * The final output is serialized into JSON format and depending on the presence of -Dprint.json.to.console.only system property,
 * it will be redirected either to a file (specified with -Doutput.json.file.path or to a default location [USER_HOME/ep/db_statistics.json])
 * or console.
 */
public enum LogParser {

	/**
	 * Log parser instance.
	 */
	INSTANCE;

	private static final Logger LOG = LoggerFactory.getLogger(LogParser.class);

	/**
	 * Main method.
	 *
	 * @param args parameters;
	 */
	public static void main(final String[] args) {
		try {
			QueryAnalyzerConfigurator.INSTANCE
					.setLogFile();


			LogParser.INSTANCE
					.printConfiguration()
					.parse()
					.generateStatistics();

		} catch (Exception e) {
			LOG.error("Error occurred", e);
		}
	}

	/**
	 * Parses log file.
	 *
	 * @return the {@link QueryStatistics} instance.
	 * @throws Exception an exception.
	 */
	public QueryStatistics parse() {
		final File inputLogFile = QueryAnalyzerConfigurator.INSTANCE.getLogFile();
		final File[] logFiles = getLogFiles(inputLogFile);

		final QueryStatistics statistics = new QueryStatistics();

		for (File logFile : logFiles) {
			LOG.debug("Parsing log file {}", logFile);

			parseLogFile(logFile, statistics);
		}

		return statistics;
	}

	private void parseLogFile(final File logFile, final QueryStatistics statistics) {
		String line;
		BufferedReader reader = null;

		try {
			reader = Files.newBufferedReader(logFile.toPath());
			ParserChain parserChain = new ParserChain(statistics, reader);
			while ((line = reader.readLine()) != null) {
				parserChain.parse(line);
			}
		} catch (Exception e) {
			throw new QueryAnalyzerException("Exception occurred while parsing a log file [" + logFile.getAbsolutePath() + "]", e);
		} finally {
			if (reader != null) {
				try {
					reader.close();
				} catch (Exception e) {
					//do nothing
				}
			}
		}
	}

	/**
	 * Restore log levels.
	 *
	 * @return this instance.
	 */
	public LogParser restoreLogLevels() {
		QueryAnalyzerConfigurator.INSTANCE.restoreLogLevels();
		return this;
	}

	/**
	 * Print parser configuration.
	 *
	 * @return this instance
	 */
	public LogParser printConfiguration() {
		QueryAnalyzerConfigurator.INSTANCE.printConfiguration();
		return this;
	}

	private File[] getLogFiles(final File logFileToParse) {
		final String logFileNamePrefix = logFileToParse.getName().split("[.]")[0];
		final File logFolder = logFileToParse.getParentFile();

		//there could be more than one log file with db statistics - we need them all
		File[] logs = logFolder.listFiles((file, fileName) -> fileName.startsWith(logFileNamePrefix));
		Arrays.sort(logs, new Comparator<File>() {
			@Override
			public int compare(final File fileOne, final File fileTwo) {
				int number1 = extractLogId(fileOne.getName());
				int number2 = extractLogId(fileTwo.getName());
				return number2 - number1;
			}

			private int extractLogId(final String name) {
				try {
					String logId = name.split("\\.")[1];
					return Integer.parseInt(logId);
				} catch (Exception e) {
					return  0;
				}
			}
		});

		return logs;
	}
}
